##从JDBC到Mybatis
###JDBC操作数据库过程
1. 加载JDBC驱动

2. 建立并获取数据库连接

3. 创建JDBC Statements对象

4. 设置SQL语句的传入参数

5. 执行SQL语句并获取查询结果

6. 对查询结果进行转换处理并将处理结果返回

7. 释放相关资源（关闭Connection，关闭Statement，关闭ResultSet）

###Mybatis操作数据库过程
1. 从配置文件(通常是XML配置文件中)得到 sessionfactory

2. 由sessionfactory产生session

3. 在session中完成对数据的增删改查和事务提交等

4. 用完之后关闭session

备注：在java对象和数据库之间有做mapping的配置文件，也通常是xml文件。

##Mybatis对于JDBC的优化
* 连接获取和释放

>问题描述：
>>数据库连接频繁的开启和关闭本身就造成了资源的浪费，影响系统的性能。

>解决问题：
>>数据库连接的获取和关闭我们可以使用数据库连接池来解决资源浪费的问题。通过连接池就可以反复利用已经建立的连接去访问数据库了。减少连接的开启和关闭的时间。
 
>问题描述：
>>当连接池多种多样，可能存在变化，有可能采用DBCP的连接池，也有可能采用容器本身的JNDI数据库连接池。
 
>解决问题：
>>们可以通过DataSource进行隔离解耦，我们统一从DataSource里面获取数据库连接，DataSource具体由DBCP实现还是由容器的JNDI实现都可以，所以我们将DataSource的具体实现通过让用户配置来应对变化。

* SQL统一存取

>问题描述：
>>我们使用JDBC进行操作数据库时，SQL语句基本都散落在各个JAVA类中，这样有三个不足之处：
第一，可读性很差，不利于维护以及做性能调优。
第二，改动Java代码需要重新编译、打包部署。
第三，不利于取出SQL在数据库客户端执行（取出后还得删掉中间的Java代码，编写好的SQL语句写好后还得通过＋号在Java进行拼凑）。
 
>解决问题：
>>我们可以考虑不把SQL语句写到Java代码中，那么把SQL语句放到哪里呢？首先需要有一个统一存放的地方，我们可以将这些SQL语句统一集中放到配置文件或者数据库里面（以key-value的格式存放）。然后通过SQL语句的key值去获取对应的SQL语句。既然我们将SQL语句都统一放在配置文件或者数据库中，那么这里就涉及一个SQL语句的加载问题。


* 传入参数映射和动态SQL
 
>问题描述：
>>很多情况下，我们都可以通过在SQL语句中设置占位符来达到使用传入参数的目的，这种方式本身就有一定局限性，它是按照一定顺序传入参数的，要与占位符一一匹配。但是，如果我们传入的参数是不确定的（比如列表查询，根据用户填写的查询条件不同，传入查询的参数也是不同的，有时是一个参数、有时可能是三个参数），那么我们就得在后台代码中自己根据请求的传入参数去拼凑相应的SQL语句，这样的话还是避免不了在Java代码里面写SQL语句的命运。既然我们已经把SQL语句统一存放在配置文件或者数据库中了，怎么做到能够根据前台传入参数不同，动态生成对应的SQL语句呢？
 
>解决问题：
>>第一，我们先解决这个动态问题，按照我们正常的程序员思维是，通过if和else这类的判断来进行是最直观的，这个时候我们想到了JSTL中的<if test=””></if>这样的标签，那么，能不能将这类的标签引入到SQL语句中呢？假设可以，那么我们这里就需要一个专门的SQL解析器来解析这样的SQL语句，但是，if判断的变量来自于哪里呢？传入的值本身是可变的，那么我们得为这个值定义一个不变的变量名称，而且这个变量名称必须和对应的值要有对应关系，可以通过这个变量名称找到对应的值，这个时候我们想到了key-value的Map。解析的时候根据变量名的具体值来判断。
假如前面可以判断没有问题，那么假如判断的结果是true，那么就需要输出的标签里面的SQL片段，但是怎么解决在标签里面使用变量名称的问题呢？这里我们需要使用一种有别于SQL的语法来嵌入变量（比如使用#{变量名}）。这样，SQL语句经过解析后就可以动态的生成符合上下文的SQL语句。
 
4. 结果映射和结果缓存
 
>问题描述：
>>执行SQL语句、获取执行结果、对执行结果进行转换处理、释放相关资源是一整套下来的。假如是执行查询语句，那么执行SQL语句后，返回的是一个ResultSet结果集，这个时候我们就需要将ResultSet对象的数据取出来，不然等到释放资源时就取不到这些结果信息了。我们从前面的优化来看，以及将获取连接、设置传入参数、执行SQL语句、释放资源这些都封装起来了，只剩下结果处理这块还没有进行封装，如果能封装起来，每个数据库操作都不用自己写那么一大堆Java代码，直接调用一个封装的方法就可以搞定了。
 
>解决问题：
>>们分析一下，一般对执行结果的有哪些处理，有可能将结果不做任何处理就直接返回，也有可能将结果转换成一个JavaBean对象返回、一个Map返回、一个List返回等等，结果处理可能是多种多样的。从这里看，我们必须告诉SQL处理器两点：第一，需要返回什么类型的对象；第二，需要返回的对象的数据结构怎么跟执行的结果映射，这样才能将具体的值copy到对应的数据结构上。接下来，我们可以进而考虑对SQL执行结果的缓存来提升性能。缓存数据都是key-value的格式，那么这个key怎么来呢？怎么保证唯一呢？即使同一条SQL语句几次访问的过程中由于传入参数的不同，得到的执行SQL语句也是不同的。那么缓存起来的时候是多对。可以将SQL语句和传入参数两部分合起来可以作为数据缓存的key值。

 
5. 解决重复SQL语句问题

>问题描述：
>>由于我们将所有SQL语句都放到配置文件中，这个时候会遇到一个SQL重复的问题，几个功能的SQL语句其实都差不多，有些可能是SELECT后面那段不同、有些可能是WHERE语句不同。有时候表结构改了，那么我们就需要改多个地方，不利于维护。
 
>解决问题：
>>当我们的代码程序出现重复代码时怎么办？将重复的代码抽离出来成为独立的一个类，然后在各个需要使用的地方进行引用。对于SQL重复的问题，我们也可以采用这种方式，通过将SQL片段模块化，将重复的SQL片段独立成一个SQL块，然后在各个SQL语句引用重复的SQL块，这样需要修改时只需要修改一处即可。
 
 
##优化总结：
1. 使用数据库连接池对连接进行管理

2. SQL语句统一存放到配置文件

3. SQL语句变量和传入参数的映射以及动态SQL

4. 动态SQL语句的处理

5. 对数据库操作结果的映射和结果缓存

6. SQL语句的重复

[原文地址：http://chenjc-it.iteye.com/blog/1455688](http://chenjc-it.iteye.com/blog/1455688)
