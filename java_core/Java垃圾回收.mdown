##Java需要垃圾回收
	Java动态分配内存，所以需要垃圾收集机制来回收内存。
##收集垃圾应该做什么
1. 那些内存需要回收

	堆 虚拟机栈 本地方法栈 方法区 程序计数器

2. 什么时候回收
	
	引用计数法 可达性分析算法

3. 如何回收

##引用
###强引用
	强引用是我们接触最多的引用，若果是强引用JVM宁愿抛出OOM也不愿回收具有强引用的对象。
###软引用
	具有软引用的对象，内存空间充足的时候，垃圾回收器不会回收，当内存空间不充足的时候，垃圾回收器回收。
###弱引用
	在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。
###虚引用
	就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。

##回收算法
**标记－清除**
![标记－清除](http://7xpxnz.com1.z0.glb.clouddn.com/jvm-%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png)
**复制算法**
![复制算法](http://7xpxnz.com1.z0.glb.clouddn.com/jvm-%E5%A4%8D%E5%88%B6.png)
**标记－整理**
![标记－整理](http://7xpxnz.com1.z0.glb.clouddn.com/jvm-%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png)
##垃圾收集器
###Serial收集器
1. 单线程

2. 工作时需要暂停用户所有线程

###ParNew收集器
1. Serial收集器的多线程版本

2. 工作时需要用户暂停所有线程，可以和CMS配合工作。

###Parallel Scavenge收集器
1. Parallel Scavenge收集器的主要目标是达到可控制吞吐量。

>吞吐量就是CPU运行用户代码的时间占CPU消耗时间的比值，即吞吐量=运行用户代码的时间/（运行用户代码的时间+垃圾收集的时间）。

###Serial Old收集器
1. Serial Old是老年代版本

2. 标记整理算法
	
###Parallel Old收集器
1. Parallel Scavenge收集器的老年代版本

2. 标记整理算法

###CMS收集器
![垃圾收集器](http://7xpxnz.com1.z0.glb.clouddn.com/jvm-%E6%94%B6%E9%9B%86%E5%99%A8.png)
1. CMS收集器（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器

2. 标记清除算法
![垃圾收集器](http://7xpxnz.com1.z0.glb.clouddn.com/jvm-CMS%E6%94%B6%E9%9B%86%E5%99%A8.png)
CMS的工作步骤：初始标记，并发标记，重新标记，并发删除。在初始标记以及重新标记的时候需要暂停用户所有线程，但是耗时非常短。初始标记就是标记直接与GC ROOT关联的对象，并发标记就是标记从GC ROOT可以连通的对象，重新标记就是在并发标记的过程中因为用户线程继续运行导致标记变更的对象的记录，最后并发清除未被标记的对象。

**CMS收集器的优点：** 
并发收集，低停顿。

**CMS收集器的缺点：** 
CMS对CPU比较敏感，默认线程数为CPU数量+3)/4，无法处理浮动垃圾（垃圾回收过程中用户线程没有停止导致），标记清楚算法会产生空间碎片。

###G1收集器
1. 标记－整理算法

2. 非常准确的控制停顿

3. 老年代，新生代收集器

##内存分配策略
1. 对象有限分配在Eden区

2. 大对象直接分配到老年代

3. 动态对象年龄判断


3. 空间分配担保
	只要老年代的连续空间大于新生代对象总大小或者历次晋升大小就Minor GC，否则就进行Full GC。
